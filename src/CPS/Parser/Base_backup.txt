module CPS.Parser.Base
  ( BaseParser,
    baseMemo,
    -- baseParse,
    baseSat,
    DeterministicAlternative(..),
  )
where

import Control.Applicative (Alternative (empty, (<|>)))
import Control.Monad (MonadPlus, guard, join)
import Control.Monad.State
  ( MonadState (get),
    State,
    StateT (..),
    evalState,
    modify,
  )
import Control.Monad.State.Lazy (gets)
import Data.Bifunctor (Bifunctor (first))
import Data.Dynamic (Dynamic (..), Typeable, fromDyn, toDyn)
import Data.HashMap.Lazy qualified as Map
import Data.Hashable (Hashable)
import Data.Typeable (typeOf)

data MemoEntry m k a r = MemoEntry {results :: [a], continuations :: [a -> m r]}

type MemoTable m k = Map.HashMap k (MemoEntry m k Dynamic Dynamic)

newtype ContState k a = ContState { r :: StateT (MemoTable (ContState k) k) [] a } deriving (Monad, Alternative, MonadPlus)

-- newtype Cont k a = Cont {runCont :: forall r. (Typeable r) => (a -> ContState k [r]) -> ContState k [r]}
newtype ContT m a = ContT {runContT :: forall r. (Typeable r) => (a -> m r) -> m r}

type BaseParser k s = StateT s (ContT (ContState (k, s)))

instance Monad (ContT k) where
  (>>=) :: ContT k a -> (a -> ContT k b) -> ContT k b
  (>>=) m f = ContT (\cont -> runContT m (\r -> runContT (f r) cont))

instance Functor (ContT k) where
  fmap :: (a -> b) -> ContT k a -> ContT k b
  fmap f m = ContT (\cont -> runContT m (cont . f))

instance Applicative (ContT k) where
  pure :: a -> ContT k a
  pure a = ContT (\cont -> cont a)
  (<*>) :: ContT k (a -> b) -> ContT k a -> ContT k b
  (<*>) f m = ContT (\cont -> runContT f (\r -> runContT (r <$> m) cont))

instance Alternative m => Alternative (ContT m) where
  empty :: ContT m a
  empty = ContT (\_ -> empty)
  (<|>) :: ContT m a -> ContT m a -> ContT m a
  (<|>) l r =
    ContT
      ( \k -> do
          runContT l k <|> runContT r k
      )

instance MonadPlus m => MonadPlus (ContT m)

infixl 3 </>

class Alternative f => DeterministicAlternative f where
  (</>) :: f a -> f a -> f a

instance DeterministicAlternative m => DeterministicAlternative (ContT m) where
  (</>) :: ContT m a -> ContT m a -> ContT m a
  (</>) l r =
    ContT
      ( \k -> runContT l k </> runContT r k
      )

-- instance DeterministicAlternative (BaseParser k s) where
--   (</>) :: BaseParser k s a -> BaseParser k s a -> BaseParser k s a
--   StateT m </> StateT n = StateT $ \s -> m s </> n s

class Memoizable m k where
  memo :: (Typeable a, Hashable k, Eq k) => k -> m a -> m a

instance Memoizable (ContT m) k where
  memo :: (Typeable a, Hashable k, Eq k) => k -> ContT m a -> ContT m a
  memo = memoCont

instance (Memoizable m (k, s), Typeable s, Hashable s, Eq s) => Memoizable (StateT s m) k where
  memo :: (Typeable a, Hashable k, Eq k) => k -> StateT s m a -> StateT s m a
  memo key parser = StateT $ \state -> memo (key, state) $ runStateT parser state

baseMemo :: (Typeable a, Hashable k, Typeable s, Hashable s, Eq k, Eq s) => k -> BaseParser k s a -> BaseParser k s a
baseMemo = memo

memoCont :: (Typeable a, Hashable k, Eq k, MonadState (MemoTable (ContState k) k) m) => k -> ContT m a -> ContT m a
memoCont key cont = ContT $ \continuation ->
    do
      -- modify $ Map.insertWith (\_ old -> old) key Map.empty
      entry <- gets $ Map.lookup key
      case entry of
        Nothing -> do
          modify $ addNewEntry key $ MemoEntry [] [toDynContinuation continuation]
          runContT
            cont
            ( \result -> do
                modify (addResult key result)
                conts <- gets $ \table -> continuations (table Map.! key)
                join <$> mapM (\cont -> fmap fromDynUnsafe <$> cont (toDyn result)) conts
            )
        Just foundEntry -> do
          modify (addContinuation key continuation)
          join <$> mapM (continuation . fromDynUnsafe) (results foundEntry)
  where
    -- toDynContinuation :: (Typeable r, Typeable a) => (a -> m r) -> Dynamic -> m Dynamic
    toDynContinuation cont x = toDyn <$> cont (fromDynUnsafe x)
    -- addNewEntry :: Hashable k => k -> MemoEntry k Dynamic Dynamic -> MemoTable k -> MemoTable k
    addNewEntry = Map.insert
    -- addResult :: (Hashable k, Typeable a) => k -> a -> MemoTable k -> MemoTable k
    addResult key res = Map.adjust (\e -> MemoEntry (toDyn res : results e) (continuations e)) key
    -- addContinuation :: (Hashable k, Typeable a, Typeable r) => k -> (a -> ContState k [r]) -> MemoTable k -> MemoTable k
    addContinuation key cont = Map.adjust (\e -> let c = MemoEntry (results e) (let b = toDynContinuation cont in b: continuations e) in c) key
    -- fromDynUnsafe :: (Typeable a) => Dynamic -> a
    fromDynUnsafe dynamic = fromDyn dynamic $ error ("Dynamic has invalid type.\nGot: " <> show (typeOf dynamic))

-- baseMemo :: (Typeable a, Hashable k, Hashable s, Eq k, Eq s) => k -> BaseParser k s a -> BaseParser k s a
-- baseMemo key parser = StateT $ \state ->
--   Cont $ \continuation ->
--     do
--       modify $ Map.insertWith (\_ old -> old) key Map.empty
--       entry <- gets $ \table -> Map.lookup state $ table Map.! key
--       case entry of
--         Nothing -> do
--           modify $ addNewEntry state $ MemoEntry [] [toDynContinuation continuation]
--           runCont
--             (runStateT parser state)
--             ( \result -> do
--                 modify (addResult state result)
--                 conts <- gets $ \table -> continuations $ (table Map.! key) Map.! state
--                 join <$> mapM (\cont -> fmap fromDynUnsafe <$> cont (first toDyn result)) conts
--             )
--         Just foundEntry -> do
--           modify (addContinuation state continuation)
--           join <$> mapM (continuation . first fromDynUnsafe) (results foundEntry)
--   where
--     toDynContinuation :: (Typeable r, Typeable a) => ((a, s) -> ContState k s [r]) -> (Dynamic, s) -> ContState k s [Dynamic]
--     toDynContinuation cont x = fmap toDyn <$> cont (first fromDynUnsafe x)
--     addNewEntry state entry table = Map.insert key (Map.insert state entry (table Map.! key)) table
--     addResult state res table = Map.insert key (Map.adjust (\e -> MemoEntry (first toDyn res : results e) (continuations e)) state (table Map.! key)) table
--     addContinuation state cont table = Map.insert key (Map.adjust (\e -> MemoEntry (results e) (toDynContinuation cont : continuations e)) state (table Map.! key)) table
--     fromDynUnsafe :: (Typeable a) => Dynamic -> a
--     fromDynUnsafe dynamic = fromDyn dynamic $ error ("Dynamic has invalid type.\nGot: " <> show (typeOf dynamic))

baseSat :: (s -> Bool) -> BaseParser k s ()
baseSat f = do
  s <- get
  guard (f s)

-- baseParse :: (Typeable s, Typeable t) => BaseParser k s t -> s -> [(t, s)]
-- baseParse p s = evalState idContState Map.empty
--   where
--     idContState = runContT (runStateT p s) (return . pure)
